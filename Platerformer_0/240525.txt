물리충돌 이벤트 Physics Trigger & Collision

Collider 컴포넌트 + Rigidbody 컴포넌트
Trigger Event Collision Event를 사용할 수 있다.

─────────────────────────────────────

Trigger - nonTrigger(Collision)

Trigger : 두 객체 사이에 물리적이 충돌이 발생하지 않고, 코드로만 충돌 이벤트 제거

Collision : 실제로 물리 충둘도 발생하고 추가적인 코드를 작성해서 커스텀할 수 있게 해줌

Trigger 체크가 되어있다. 지나간다.

Trigger 체크 안 됨. 충돌.

─────────────────────────────────────
【OnTrigger "XXX" 2d】

Enter : 충돌이 처음 일어난 시점에서, 1회 발생하는 이벤트 함수
ㄴ간단한 충돌 이벤트를 구현할 때 많이 사용

Stay : Enter ~ Exit 시점까지 매 프레임마다 실행하는 이벤트 함수
ㄴ추가적인 코드 없이 반복적인 코드를 실행하기 위해 사용

Exit : 충돌이 끝나는 시점에서, 1회 발생하는 이벤트 함수
ㄴ Stay 성능 개선을 위해 Enter와 같이 사용하거나 특정 시점에서 발생되기를 원할 때 사용

─────────────────────────────────────
Stay 사용예제)

Enter, Exit에 해당하는 상태를 작성하지 않아도 체력이 감소하는 코드를 적용할 수 있음
OnTiggerStay 함수를 사용하면 간편하게 현재 충돌중인 상태의 기능을 구현할 수 있음
Stay 외의 상황 제어 불가능
Stay Envet 시점에서 작성되는 코드 관리하기 어려움
유니티에서 제공해주는 간편한 함수
유연한 코드 작성보다는 간단하고 빠르게 구현하기 위한 목적

─────────────────────────────────────
Stay 대체)

Update 조건문을 작성하여 기능을 구현
제어하는 변수를 사용하여 직접 코드 관리



─────────────────────────────────────
【Prefab】
계층구조에 추가한 오브젝트를 프로텍트 데이터로 저장해서 필요할 때마다 꺼내서 사용

1. 동일한 프리팹을 일괄적으로 수정할 수 있다. (유지보수가 쉬운 캡슐화)
2. 서로 다른 Scence에서 데이터를 로드할 수 있다. (다른 사람이 만든 Scene에서 쓸 수 있다.)

1. Project 뷰에서 저장하고 싶은 위치 이동 - 마우스 우클릭 - Create - Prefab

─────────────────────────────────────
【Nested Prefabl】 프리팹 안의 프리팹

이미 프리팹이 되어있는 데이터 요소를 다시 프래팹화하는 것

사용하는 건 비추천
이유 : 

─────────────────────────────────────
【Prefab 해제】
필요없는 요소를 프리팹화시켰을 경우 해제하는 방법(객체 우클릭 후 Prefab - Unpack)

─────────────────────────────────────
【Prefab Variant】
프리팹으로 동일한 데이터를 다루되, 특정 요소만 다르게 하는 방법

이미 만들어져있는 Prefab에 우클릭 - Prefab Variant

부모가 바뀌면 자식도 모두 바뀜.
동일한 데이터를 Prefab date로 유지하되, Variant 특정 컴포넌트만 다르게 설정하는 것
동일해야만 하는 데이터를 유지하면서 다양한 오브젝트를 만드는 방법을 지원해주는 것

────────────────────────────────────
코드로 프리팹을 제어하는 방법

프리팹은 프로젝트 뷰(공간) 데이터로 존재하는 것
데이터를 Scene에 로드하는 법 : 드래그 앤 드롭으로 계층창에 끌고 옴
모든 프로젝트 데이터 코드에서 신으로 생성할 수 있게 구현이 됨

────────────────────────────────────
【Prefab 정리】
1. 동일한 속성을 가진 데이터를 프리팹으로 만들어서 관리를 할 수 있다.
2. 빠른 개발을 위해서는 프리팹을 적극적으로 사용함
3. 사용하는 방법으로 Project 뷰에서 드래그 앤 드롭으로 미리 배치해서 사용할 수 있으며
4. Gameobject(Instantiate)를 이용해서 우리가 원하는 시점에서 오브젝트를 생성, 배치할 수 있음

────────────────────────────────────
Instantiate 인스턴트화

클래스 -> 인스터트 생성 : "new 클래스 이름()"

────────────────────────────────────
Instantiate 사용 시 주의

Inspector 창에 Public으로 등록된 데이터들을 Scene에서 변수를 연결해줌
Prefab에 같이 저장되어있지 않은 오브젝트에는 접근을 할 수 없음
Scene에서 변수를 초기화한 데이터들의 연결이 끊어지게 됩니다
Null Reference Error -> 버그를 수정해야 하는 상황이 옴.

────────────────────────────────────
→ 해결법 : 코드로 데이터를 연결하는 방법
private
public
SerializedField
HideInInspector
GetComponent

────────────────────────────────────

priavete vs public
C# 은닉화에 대한 내용

private 왜 써야 하나요?
- 필요 없는 정보는 사용자에게 숨기고
- 개발자가 접근하면 안 되는 부분을 원천적으로 막기 위해 사용

public 공통으로 사용하기 위함
- 빠르게 수정 가능하기 때문에 편리함
- 공용 변수 같은 경우에는 public으로 선언해서 모두가 사용하게 해야합니다

────────────────────────────────────

문제가 발생 Prefab을 생성할 때 변수를 연결하지 못하는 현상..
private 선언은 했는데 변수는 Scene에서 사용하고 싶음 

[SerializedField] private 변수 이름 -> 인스펙터 창에 노출됨
[HideInInspector] public 변수 이름 -> 인스펙터 상에 노출이 안 되는 기능

코드로 Script에 있는 변수에 접근할 수 있어야 함
모든 오브젝트들은 Component를 가짐으로써 기능을 구현하게 되고
Component를 접근해서 변수로 사용할 수 있음

GetComponent<>0

GetComponent() :  선언한 오브젝트 위치에서 T 타입의 변수를 가져와 T를 반환
GetComponentInChildren : + 오브젝트의 자식도 찾아와서 가져와라 (가장 먼저 발견한 대상을 반환)
GetComponentInParent<> : + 오브젝트의 부모도 찾아와서 가져와라 (가장 먼저 발견한 대상을 반환)

GetComponentsInChildren : 오브젝트 + 자식의 오브젝트 T타입 모든 데이터를 찾아서 반환
복수의 오브젝트를 담을 수 있는 데이터 타입으로 반환 필요(Array, List, Queue, Stack 등)

GetComponentsInParent : 

변수이름 = GetComponent()
